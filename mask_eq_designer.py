"""
Mask EQ Designer - Graphic equalizer with minimum-phase FFT mask generation

This application provides a graphical interface for designing frequency-domain EQ masks
used in embedded DSP applications. Features include:
- 14-band graphic EQ with adjustable sliders (85 Hz - 8 kHz)
- Interactive dot dragging on frequency response plot
- Real-time frequency response visualization
- Minimum-phase response generation using cepstral method
- Export to C header file for embedded systems (interleaved real/imag format)
- Export frequency response and time-domain impulse response plots
- Load target curves from text files
- Preset curves (Flat, Bass Filter)

Example usage:
    python mask_eq_designer.py

    To change parameters, edit the CONFIGURABLE PARAMETERS section below.

Default parameters:
- Sample rate: 16000 Hz
- FFT size: 256 (output: 129 bins)
- Number of EQ bands: 14
- Slider range: -18 dB to +18 dB
"""

import customtkinter as ctk
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure
import numpy as np
from scipy import signal
from tkinter import filedialog, messagebox
import os
from datetime import datetime


# ============================================================================
# CONFIGURABLE PARAMETERS
# ============================================================================

class Config:
    """Application configuration - modify these values as needed"""
    SAMPLE_RATE = 16000         # Sample rate in Hz
    FFT_SIZE = 256              # FFT size (output will be FFT_SIZE/2 + 1 bins)
    NUM_BANDS = 14              # Number of graphic EQ bands
    MIN_GAIN_DB = -18.0         # Minimum slider gain in dB
    MAX_GAIN_DB = 18.0          # Maximum slider gain in dB

    # GUI Settings
    WINDOW_WIDTH = 1200
    WINDOW_HEIGHT = 700
    PLOT_HEIGHT = 250

    @property
    def num_bins(self):
        """Number of output FFT bins"""
        return self.FFT_SIZE // 2 + 1

    @property
    def nyquist_freq(self):
        """Nyquist frequency"""
        return self.SAMPLE_RATE / 2


# ============================================================================
# EQ MASK GENERATION
# ============================================================================

class EQMaskGenerator:
    """Generate minimum-phase EQ masks from magnitude response"""

    def __init__(self, config):
        self.config = config

    def generate_minimum_phase_mask(self, freqs, gains_db):
        """
        Generate minimum-phase complex FFT mask from frequency/gain pairs

        Args:
            freqs: Array of frequencies in Hz
            gains_db: Array of gains in dB

        Returns:
            Tuple of (bin_freqs, complex_mask, actual_magnitude)
        """
        # Create frequency bins for FFT
        bin_freqs = np.linspace(0, self.config.nyquist_freq, self.config.num_bins)

        # Interpolate gains to match FFT bins
        gains_db_interp = np.interp(bin_freqs, freqs, gains_db)

        # Convert dB to linear magnitude
        magnitude = 10 ** (gains_db_interp / 20.0)

        # Generate minimum phase from magnitude using Hilbert transform
        # This is the standard method for minimum-phase reconstruction

        # Take log magnitude (with small epsilon to avoid log(0))
        log_magnitude = np.log(np.maximum(magnitude, 1e-10))

        # Create full symmetric log magnitude for FFT
        # [DC, f1, f2, ..., fN/2] -> [DC, f1, ..., fN/2, fN/2-1, ..., f1]
        full_log_mag = np.concatenate([log_magnitude, log_magnitude[-2:0:-1]])

        # Apply FFT to get cepstrum
        cepstrum = np.fft.ifft(full_log_mag).real

        # Create minimum phase cepstrum (causal window)
        min_phase_cepstrum = np.zeros_like(cepstrum)
        min_phase_cepstrum[0] = cepstrum[0]  # DC
        min_phase_cepstrum[1:self.config.FFT_SIZE//2] = 2 * cepstrum[1:self.config.FFT_SIZE//2]  # Positive freqs

        # Transform back to get minimum phase spectrum
        min_phase_log_spectrum = np.fft.fft(min_phase_cepstrum)

        # Convert from log domain to linear domain
        full_complex_mask = np.exp(min_phase_log_spectrum)

        # Extract first half (including Nyquist)
        complex_mask = full_complex_mask[:self.config.num_bins]

        # Get actual magnitude for verification
        actual_magnitude = np.abs(complex_mask)

        return bin_freqs, complex_mask, actual_magnitude

    def export_to_header(self, complex_mask, filename):
        """
        Export complex mask to C header file with interleaved real/imag format

        Args:
            complex_mask: Complex array of FFT coefficients
            filename: Output .h filename
        """
        with open(filename, 'w') as f:
            f.write(f"// Generated by Mask EQ Designer on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"// Sample rate: {self.config.SAMPLE_RATE} Hz\n")
            f.write(f"// FFT size: {self.config.FFT_SIZE}\n")
            f.write(f"// Number of complex bins: {self.config.num_bins}\n")
            f.write(f"//\n")
            f.write(f"// Format: Interleaved real/imaginary pairs (Python FFT output style)\n")
            f.write(f"// Array layout: [real0, imag0, real1, imag1, real2, imag2, ...]\n")
            f.write(f"// - Bin 0 (DC): real value, imag=0\n")
            f.write(f"// - Bins 1 to {self.config.FFT_SIZE//2-1}: complex pairs (real, imag)\n")
            f.write(f"// - Bin {self.config.FFT_SIZE//2} (Nyquist): real value, imag=0\n")
            f.write(f"// Total elements: {self.config.num_bins * 2}\n\n")

            # Interleaved format
            array_size = self.config.num_bins * 2
            f.write(f"float eq_mask[{array_size}] = {{\n")

            for i in range(self.config.num_bins):
                # Write real part
                f.write(f"    {complex_mask[i].real:.8f}f, ")
                # Write imaginary part
                f.write(f"{complex_mask[i].imag:.8f}f")

                # Add comma if not the last pair
                if i < self.config.num_bins - 1:
                    f.write(",")

                # Add comment for readability
                if i == 0:
                    f.write("  // Bin 0: DC")
                elif i == self.config.num_bins - 1:
                    f.write(f"  // Bin {i}: Nyquist")
                elif i % 16 == 0:
                    f.write(f"  // Bin {i}")

                f.write("\n")

            f.write("};\n")


# ============================================================================
# GUI APPLICATION
# ============================================================================

class MaskEQDesignerApp:
    """Main application window for Mask EQ Designer"""

    def __init__(self):
        self.config = Config()
        self.eq_generator = EQMaskGenerator(self.config)

        # Initialize GUI
        ctk.set_appearance_mode("dark")
        ctk.set_default_color_theme("blue")

        self.root = ctk.CTk()
        self.root.title("Mask EQ Designer")
        self.root.geometry(f"{self.config.WINDOW_WIDTH}x{self.config.WINDOW_HEIGHT}")

        # Generate frequency centers for EQ bands (octave spacing)
        self.band_freqs = self._generate_band_frequencies()

        # Initialize slider gains (all at 0 dB)
        self.band_gains = [0.0] * self.config.NUM_BANDS

        # State for interactive dot dragging
        self.dragging_index = None  # Track which band is being dragged
        self.scatter_plot = None    # Reference to scatter plot for picking

        # Build GUI
        self._build_gui()

        # Initial plot
        self.update_plot()

    def _generate_band_frequencies(self):
        """Generate frequency centers for EQ bands with octave spacing"""
        # Start from a low frequency and space octaves
        start_freq = 85
        max_freq = self.config.nyquist_freq

        freqs = []
        freq = start_freq
        while freq <= max_freq and len(freqs) < self.config.NUM_BANDS:
            freqs.append(freq)
            freq *= 2  # Octave spacing

        # If we need more bands, fill in with log spacing
        if len(freqs) < self.config.NUM_BANDS:
            freqs = np.logspace(np.log10(start_freq),
                              np.log10(max_freq),
                              self.config.NUM_BANDS)

        return np.array(freqs[:self.config.NUM_BANDS])

    def _build_gui(self):
        """Build the GUI layout"""
        # Configure grid weights for resizing
        self.root.grid_rowconfigure(0, weight=1)
        self.root.grid_rowconfigure(1, weight=0)
        self.root.grid_rowconfigure(2, weight=0)
        self.root.grid_columnconfigure(0, weight=1)

        # Top frame: Matplotlib plot
        self.plot_frame = ctk.CTkFrame(self.root)
        self.plot_frame.grid(row=0, column=0, padx=10, pady=10, sticky="nsew")

        # Create matplotlib figure
        self.fig = Figure(figsize=(10, 3), dpi=100, facecolor='#2b2b2b')
        self.ax = self.fig.add_subplot(111)
        self.ax.set_facecolor('#1e1e1e')
        self.ax.set_xlabel('Frequency (Hz)', color='white')
        self.ax.set_ylabel('Gain (dB)', color='white')
        self.ax.set_title('Frequency Response', color='white')
        self.ax.grid(True, alpha=0.3, color='gray')
        self.ax.tick_params(colors='white')

        self.canvas = FigureCanvasTkAgg(self.fig, master=self.plot_frame)
        self.canvas.get_tk_widget().pack(fill='both', expand=True)

        # Connect matplotlib event handlers for interactive dots
        self.canvas.mpl_connect('pick_event', self.on_pick)
        self.canvas.mpl_connect('motion_notify_event', self.on_drag)
        self.canvas.mpl_connect('button_release_event', self.on_release)

        # Middle frame: EQ sliders
        self.sliders_frame = ctk.CTkFrame(self.root)
        self.sliders_frame.grid(row=1, column=0, padx=10, pady=10, sticky="ew")

        self.sliders = []
        self.slider_labels = []

        for i in range(self.config.NUM_BANDS):
            # Container for each slider
            slider_container = ctk.CTkFrame(self.sliders_frame)
            slider_container.grid(row=0, column=i, padx=5, pady=5)

            # Gain label
            gain_label = ctk.CTkLabel(slider_container, text="0.0 dB", width=60)
            gain_label.pack(pady=2)
            self.slider_labels.append(gain_label)

            # Slider
            slider = ctk.CTkSlider(
                slider_container,
                from_=self.config.MIN_GAIN_DB,  # Bottom of slider (-18 dB)
                to=self.config.MAX_GAIN_DB,     # Top of slider (+18 dB)
                orientation="vertical",
                height=200,
                command=lambda val, idx=i: self.on_slider_change(idx, val)
            )
            slider.set(0)  # Start at 0 dB
            slider.pack(pady=5)
            self.sliders.append(slider)

            # Frequency label
            freq_str = self._format_frequency(self.band_freqs[i])
            freq_label = ctk.CTkLabel(slider_container, text=freq_str, width=60)
            freq_label.pack(pady=2)

        # Bottom frame: Control buttons
        self.controls_frame = ctk.CTkFrame(self.root)
        self.controls_frame.grid(row=2, column=0, padx=10, pady=10, sticky="ew")

        # Buttons
        btn_flat = ctk.CTkButton(self.controls_frame, text="Flat", command=self.preset_flat, width=100)
        btn_flat.grid(row=0, column=0, padx=5, pady=5)

        btn_bass = ctk.CTkButton(self.controls_frame, text="Bass Filter", command=self.preset_bass_filter, width=100)
        btn_bass.grid(row=0, column=1, padx=5, pady=5)

        btn_load = ctk.CTkButton(self.controls_frame, text="Load File", command=self.load_from_file, width=100)
        btn_load.grid(row=0, column=2, padx=5, pady=5)

        btn_export = ctk.CTkButton(self.controls_frame, text="Export", command=self.export_mask, width=100)
        btn_export.grid(row=0, column=3, padx=5, pady=5)

        # Config info label
        info_text = f"SR: {self.config.SAMPLE_RATE}Hz | FFT: {self.config.FFT_SIZE} | Bins: {self.config.num_bins}"
        info_label = ctk.CTkLabel(self.controls_frame, text=info_text)
        info_label.grid(row=0, column=4, padx=20, pady=5)

    def _format_frequency(self, freq):
        """Format frequency for display"""
        if freq >= 1000:
            return f"{freq/1000:.1f}k"
        else:
            return f"{int(freq)}"

    def on_slider_change(self, index, value):
        """Handle slider value change"""
        self.band_gains[index] = float(value)
        self.slider_labels[index].configure(text=f"{value:.1f} dB")
        self.update_plot()

    def update_plot(self):
        """Update the frequency response plot"""
        # Generate mask
        bin_freqs, complex_mask, actual_magnitude = self.eq_generator.generate_minimum_phase_mask(
            self.band_freqs, self.band_gains
        )

        # Convert to dB
        actual_db = 20 * np.log10(np.maximum(actual_magnitude, 1e-10))

        # Create interpolated target curve for visualization
        target_curve = np.interp(bin_freqs, self.band_freqs, self.band_gains)

        # Clear and plot
        self.ax.clear()

        # Plot target curve (semi-transparent orange)
        self.ax.semilogx(bin_freqs, target_curve, color='orange', alpha=0.4,
                        linewidth=1.5, label='Target Curve')

        # Plot actual response (cyan)
        self.ax.semilogx(bin_freqs, actual_db, 'cyan', linewidth=2, label='Actual Response')

        # Plot target band points (solid orange, pickable)
        self.scatter_plot = self.ax.scatter(self.band_freqs, self.band_gains, color='orange', s=50,
                       zorder=5, label='Target', picker=True, pickradius=10)

        self.ax.set_xlabel('Frequency (Hz)', color='white')
        self.ax.set_ylabel('Gain (dB)', color='white')
        self.ax.set_title('Frequency Response', color='white')
        self.ax.set_xlim([20, self.config.nyquist_freq])
        self.ax.set_ylim([self.config.MIN_GAIN_DB - 2, self.config.MAX_GAIN_DB + 2])
        self.ax.grid(True, alpha=0.3, color='gray', which='both')
        self.ax.tick_params(colors='white')
        self.ax.legend(facecolor='#2b2b2b', edgecolor='white', labelcolor='white')

        self.canvas.draw()

    def on_pick(self, event):
        """Handle pick event when user clicks on a target dot"""
        if event.artist == self.scatter_plot:
            # Get the index of the clicked point
            if len(event.ind) > 0:
                self.dragging_index = event.ind[0]

    def on_drag(self, event):
        """Handle drag event to move target dot up/down"""
        if self.dragging_index is None or event.ydata is None:
            return

        # Get new gain value from mouse y-coordinate
        new_gain = event.ydata

        # Clamp to valid range
        new_gain = np.clip(new_gain, self.config.MIN_GAIN_DB, self.config.MAX_GAIN_DB)

        # Update band gain
        self.band_gains[self.dragging_index] = new_gain

        # Update corresponding slider and label
        self.sliders[self.dragging_index].set(new_gain)
        self.slider_labels[self.dragging_index].configure(text=f"{new_gain:.1f} dB")

        # Redraw plot
        self.update_plot()

    def on_release(self, event):
        """Handle mouse release to end dragging"""
        self.dragging_index = None

    def preset_flat(self):
        """Set all bands to 0 dB (flat response)"""
        for i in range(self.config.NUM_BANDS):
            self.band_gains[i] = 0.0
            self.sliders[i].set(0.0)
            self.slider_labels[i].configure(text="0.0 dB")
        self.update_plot()

    def preset_bass_filter(self):
        """Set bass filter preset: +6 dB at 100 Hz sloping to -6 dB at 8 kHz"""
        # Interpolate between 100 Hz (+6 dB) and 8000 Hz (-6 dB)
        for i in range(self.config.NUM_BANDS):
            freq = self.band_freqs[i]
            # Linear interpolation in log frequency space
            if freq <= 100:
                gain = 6.0
            elif freq >= 8000:
                gain = -6.0
            else:
                # Log interpolation
                log_ratio = (np.log10(freq) - np.log10(100)) / (np.log10(8000) - np.log10(100))
                gain = 6.0 - 12.0 * log_ratio

            self.band_gains[i] = gain
            self.sliders[i].set(gain)
            self.slider_labels[i].configure(text=f"{gain:.1f} dB")

        self.update_plot()

    def load_from_file(self):
        """Load frequency/gain pairs from text file"""
        filename = filedialog.askopenfilename(
            title="Select EQ curve file",
            filetypes=[("Text files", "*.txt"), ("All files", "*.*")]
        )

        if not filename:
            return

        try:
            # Parse file: freq_hz gain_db (space or tab separated)
            data = np.loadtxt(filename)

            if data.ndim == 1:
                # Single line
                data = data.reshape(1, -1)

            if data.shape[1] < 2:
                messagebox.showerror("Error", "File must contain at least 2 columns: freq_hz gain_db")
                return

            file_freqs = data[:, 0]
            file_gains = data[:, 1]

            # Interpolate to band frequencies
            for i in range(self.config.NUM_BANDS):
                gain = np.interp(self.band_freqs[i], file_freqs, file_gains)
                gain = np.clip(gain, self.config.MIN_GAIN_DB, self.config.MAX_GAIN_DB)
                self.band_gains[i] = gain
                self.sliders[i].set(gain)
                self.slider_labels[i].configure(text=f"{gain:.1f} dB")

            self.update_plot()
            messagebox.showinfo("Success", f"Loaded curve from {os.path.basename(filename)}")

        except Exception as e:
            messagebox.showerror("Error", f"Failed to load file: {str(e)}")

    def export_mask(self):
        """Export EQ mask to .h file and save frequency response and impulse response plots as PNG"""
        # Ask for filename
        filename = filedialog.asksaveasfilename(
            title="Save EQ mask as",
            defaultextension=".h",
            filetypes=[("Header files", "*.h"), ("All files", "*.*")]
        )

        if not filename:
            return

        try:
            # Generate mask
            bin_freqs, complex_mask, actual_magnitude = self.eq_generator.generate_minimum_phase_mask(
                self.band_freqs, self.band_gains
            )

            # Export to header file
            self.eq_generator.export_to_header(complex_mask, filename)

            # Save plot as PNG (same name, different extension)
            png_filename = os.path.splitext(filename)[0] + ".png"

            # Create comparison plot
            fig_export = plt.figure(figsize=(10, 6))
            ax_export = fig_export.add_subplot(111)

            actual_db = 20 * np.log10(np.maximum(actual_magnitude, 1e-10))

            ax_export.semilogx(bin_freqs, actual_db, 'b-', linewidth=2, label='Actual Response')
            ax_export.scatter(self.band_freqs, self.band_gains, color='red', s=80, zorder=5, label='Target')

            ax_export.set_xlabel('Frequency (Hz)')
            ax_export.set_ylabel('Gain (dB)')
            ax_export.set_title('EQ Mask: Target vs Actual Magnitude Response')
            ax_export.set_xlim([20, self.config.nyquist_freq])
            ax_export.set_ylim([self.config.MIN_GAIN_DB - 2, self.config.MAX_GAIN_DB + 2])
            ax_export.grid(True, alpha=0.3, which='both')
            ax_export.legend()

            fig_export.savefig(png_filename, dpi=150, bbox_inches='tight')
            plt.close(fig_export)

            # Generate time-domain impulse response plot
            impulse_png_filename = os.path.splitext(filename)[0] + "_impulse.png"

            # Create full symmetric spectrum for IFFT
            full_spectrum = np.concatenate([complex_mask, np.conj(complex_mask[-2:0:-1])])

            # IFFT to get time-domain impulse response
            impulse_response = np.fft.ifft(full_spectrum).real

            # Create impulse response plot
            fig_impulse = plt.figure(figsize=(10, 6))
            ax_impulse = fig_impulse.add_subplot(111)

            # Time axis in milliseconds
            time_ms = np.arange(len(impulse_response)) * 1000.0 / self.config.SAMPLE_RATE

            ax_impulse.plot(time_ms, impulse_response, 'b-', linewidth=1.5)
            ax_impulse.set_xlabel('Time (ms)')
            ax_impulse.set_ylabel('Amplitude')
            ax_impulse.set_title('EQ Mask: Time-Domain Impulse Response')
            ax_impulse.grid(True, alpha=0.3)
            ax_impulse.axhline(y=0, color='k', linewidth=0.5, alpha=0.3)

            fig_impulse.savefig(impulse_png_filename, dpi=150, bbox_inches='tight')
            plt.close(fig_impulse)

            messagebox.showinfo("Success",
                              f"Exported:\n{os.path.basename(filename)}\n{os.path.basename(png_filename)}\n{os.path.basename(impulse_png_filename)}")

        except Exception as e:
            messagebox.showerror("Error", f"Failed to export: {str(e)}")

    def run(self):
        """Start the GUI application"""
        self.root.mainloop()


# ============================================================================
# MAIN ENTRY POINT
# ============================================================================

if __name__ == "__main__":
    app = MaskEQDesignerApp()
    app.run()
